import tkinter as tk
from tkinter import scrolledtext, filedialog, messagebox, ttk
import threading
import os
import subprocess
import sys
import queue
import json
import webbrowser
from datetime import datetime
from typing import Optional, Dict
from generate_podcast import validate_speakers  # Importez la nouvelle fonction

# --- Versioning ---
# This file is automatically generated by setuptools-scm
from _version import __version__

AVAILABLE_VOICES = {
    "Zephyr": "Bright",
    "Puck": "Upbeat",
    "Charon": "Informative",
    "Kore": "Firm",
    "Fenrir": "Excitable",
    "Leda": "Youthful",
    "Orus": "Firm",
    "Aoede": "Breezy",
    "Callirrhoe": "Easy-going",
    "Autonoe": "Bright",
    "Enceladus": "Breathy",
    "Iapetus": "Clear",
    "Umbriel": "Easy-going",
    "Algieba": "Smooth",
    "Despina": "Smooth",
    "Erinome": "Clear",
    "Algenib": "Gravelly",
    "Rasalgethi": "Informative",
    "Laomedeia": "Upbeat",
    "Achernar": "Soft",
    "Alnilam": "Firm",
    "Schedar": "Even",
    "Gacrux": "Mature",
    "Pulcherrima": "Forward",
    "Achird": "Friendly",
    "Zubenelgenubi": "Casual",
    "Vindemiatrix": "Gentle",
    "Sadachbia": "Lively",
    "Sadaltager": "Knowledgeable",
    "Sulafat": "Warm"
}


def get_app_version() -> str:
    """Gets the application version from the _version.py file."""
    return __version__


def get_asset_path(filename: str) -> Optional[str]:
    """
    Gets the absolute path to an asset, handling running from source and from
    a PyInstaller bundle.
    """
    if getattr(sys, 'frozen', False):
        # The application is frozen (packaged with PyInstaller)
        bundle_dir = sys._MEIPASS
    else:
        # The application is running in a normal Python environment
        bundle_dir = os.path.dirname(os.path.abspath(__file__))

    path = os.path.join(bundle_dir, filename)
    return path if os.path.exists(path) else None


class PodcastGeneratorApp:
    DEFAULT_SPEAKER_SETTINGS = {"John": "Schedar - Even", "Samantha": "Zephyr - Bright"}
    DEFAULT_APP_SETTINGS = {
        "tts_provider": "gemini",
        "speaker_voices": {"John": "Schedar - Even", "Samantha": "Zephyr - Bright"},
        "speaker_voices_elevenlabs": {
            "John": {"id": "nPczCjzI2devNBz1zQrb", "display_name": "Brian - Male, Middle_Aged, american"},
            "Samantha": {"id": "XB0fDUnXU5powFXDhCwa", "display_name": "Charlotte - Female, Young, swedish"}
        },
        "elevenlabs_quota_cache": None
    }

    def __init__(self, root: tk.Tk, generate_func, logger, api_key: str, default_script: str = ""):
        self.root = root
        self.root.title(f"Podcast Generator v{get_app_version()}")
        self.root.geometry("960x700")
        # --- Application Icon ---
        icon_path = get_asset_path("podcast.png")
        if icon_path:
            try:
                img = tk.PhotoImage(file=icon_path)
                self.root.tk.call('wm', 'iconphoto', self.root._w, img)
            except tk.TclError:
                # In case of format error, continue without icon
                pass

        # --- Define configuration paths ---
        from generate_podcast import get_app_data_dir, find_ffplay_path  # Local import
        self.app_data_dir = get_app_data_dir()
        self.settings_filepath = os.path.join(self.app_data_dir, "settings.json")

        self.generate_func = generate_func
        self.logger = logger
        self.api_key = api_key
        self.log_queue = queue.Queue()
        self.playback_obj = None  # To keep a reference to the playback process
        self.last_generated_filepath = None
        self.ffplay_path = find_ffplay_path()
        self.elevenlabs_quota_text = None # New state variable

        self.app_settings = self.load_settings()

        # Provider sélectionné
        self.provider_var = tk.StringVar(value=self.app_settings.get("tts_provider", "gemini").lower())
        if self.app_settings.get("tts_provider", "gemini").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

        # Cache des voix ElevenLabs préchargées
        self.elevenlabs_voices_cache = []

        # --- Menu Bar (Platform-specific) ---
        self.menubar = tk.Menu(self.root)
        self.root.config(menu=self.menubar)

        if sys.platform == "darwin":  # macOS
            try:
                # Create the special "app" menu. This can fail on non-native Tcl/Tk.
                app_menu = tk.Menu(self.menubar, name='apple', tearoff=0)
                self.menubar.add_cascade(label="Podcast Generator", menu=app_menu)

                app_menu.add_command(label=f"About Podcast Generator", command=self.show_about_window)
                app_menu.add_separator()
                app_menu.add_command(label="Voice settings...", command=self.open_settings_window,
                                     accelerator="Command+,")
                app_menu.add_separator()
                # Add standard macOS services for a native feel
                app_menu.add_command(label="Services", role="services")
                app_menu.add_separator()
                app_menu.add_command(label="Hide Podcast Generator", accelerator="Command+H", role="hide")
                app_menu.add_command(label="Hide Others", accelerator="Command+Option+H", role="hideothers")
                app_menu.add_command(label="Show All", role="unhide")
                app_menu.add_separator()
                app_menu.add_command(label="Quit Podcast Generator", accelerator="Command+Q", role="quit")
            except tk.TclError:
                # Fallback for older Tcl/Tk. Clear any partially created menu.
                self.menubar.delete(0, 'end')
                # (Le menu Settings sera créé plus bas, commun à toutes les plateformes)
        # Création du menu Settings (commun à toutes les plateformes)
        self.settings_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Settings", menu=self.settings_menu)

        # Entrées du menu Settings: Voice settings
        self.settings_menu.add_command(label="Voice settings...", command=self.open_settings_window)

        # Sous-menu TTS provider (n’apparaît que si 2 clés sont présentes)
        self.settings_menu.add_separator()
        self.tts_submenu = None
        self.rebuild_tts_provider_menu()

        # Gestion des clés API
        self.settings_menu.add_separator()
        self.settings_menu.add_command(label="Manage API Keys...", command=self.open_api_keys_window)

        # Quit (pour Windows/Linux; sur macOS l'app menu expose déjà Quit)
        if sys.platform != "darwin":
            self.settings_menu.add_separator()
            self.settings_menu.add_command(label="Quit", command=self.root.quit)

        # Help Menu (common to all platforms)
        help_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Documentation (Github)...", command=self.open_documentation)
        help_menu.add_command(label="About...", command=self.show_about_window)
        self.logger.info("Main interface initialized.")

        self.poll_log_queue()
        # car les boutons ne sont pas encore créés.

        # --- Main Frame ---
        main_frame = tk.Frame(root, padx=10, pady=10)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- TTS Provider Status Bar ---
        status_frame = tk.Frame(main_frame, relief=tk.SUNKEN, bd=1)
        status_frame.pack(fill=tk.X, pady=(0, 5))

        current_provider = self.app_settings.get("tts_provider", "gemini").title()
        # Couleur adaptative selon le mode sombre macOS
        self._is_dark_mode = self._is_macos_dark_mode()
        text_color = "white" if self._is_dark_mode else "blue"
        self.provider_label = tk.Label(status_frame, text=f"TTS Provider: {current_provider}", font=('Helvetica', 9),
                                       fg=text_color)
        self.provider_label.pack(side=tk.LEFT, padx=5, pady=2)
        # Déclenche le rafraîchissement du quota immédiatement si ElevenLabs est actif
        if self.app_settings.get("tts_provider", "gemini").lower() == "elevenlabs":
            cached = self.app_settings.get("elevenlabs_quota_cache") or {}
            cached_text = cached.get("text")
            if cached_text:
                self.elevenlabs_quota_text = cached_text
                self._update_provider_label()
            self.update_elevenlabs_quota_in_status()
        # Lance le watcher de thème (actualise la couleur s'il y a bascule sombre/clair)
        self._start_theme_watcher()

        # --- Script Text Area ---
        script_frame = tk.LabelFrame(main_frame, text="Script to read", padx=5, pady=5)
        script_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))


        self.script_text = scrolledtext.ScrolledText(script_frame, wrap=tk.WORD, height=15, width=80)
        self.script_text.pack(fill=tk.BOTH, expand=True)
        self.script_text.insert(tk.END, default_script)

        # --- Log/Status Area ---
        log_frame = tk.LabelFrame(main_frame, text="Generation status", padx=5, pady=5)
        log_frame.pack(fill=tk.BOTH, expand=True)

        self.log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, height=10, state='disabled')
        self.log_text.pack(fill=tk.BOTH, expand=True)

        # --- Progress Bar (initially hidden) ---
        self.progress_bar = ttk.Progressbar(main_frame, mode='indeterminate')

        # --- Button Frame ---
        self.button_frame = tk.Frame(main_frame)
        self.button_frame.pack(fill=tk.X, pady=(10, 0))

        # Define a common width for visual consistency
        common_button_width = 22

        # --- Left-aligned buttons ---
        self.load_button = tk.Button(self.button_frame, text="Load a script (.txt)", command=self.load_script_from_file,
                                     width=common_button_width)
        self.load_button.pack(side=tk.LEFT, padx=(0, 5))

        self.generate_button = tk.Button(self.button_frame, text="Start generation",
                                         command=self.start_generation_thread, width=common_button_width)
        self.generate_button.pack(side=tk.LEFT)

        # --- Right-aligned buttons (packed in reverse order for correct display) ---
        self.show_button = tk.Button(self.button_frame, text="Open file location", command=self.open_file_location,
                                     state='disabled', width=common_button_width)
        self.show_button.pack(side=tk.RIGHT, padx=(5, 0))

        self.play_button = tk.Button(self.button_frame, text="▶️ Play", command=self.play_last_generated_file,
                                     state='disabled', width=common_button_width)
        self.play_button.pack(side=tk.RIGHT)
        # Après que tous les widgets (dont generate_button) sont créés, on peut mettre à jour les états.
        self.update_provider_menu_state()
        self.update_voice_settings_enabled()
        # Force un rafraîchissement différé du label pour laisser le temps au quota d'arriver
        if self.app_settings.get("tts_provider", "gemini").lower() == "elevenlabs":
            self._schedule_provider_label_refresh(delay_ms=2000, retries=5)

    def _is_macos_dark_mode(self) -> bool:
        """Retourne True si macOS est en mode sombre, False sinon (ou si indétectable)."""
        try:
            if sys.platform != "darwin":
                return False
            # AppleInterfaceStyle existe seulement en mode sombre
            proc = subprocess.run(
                ["defaults", "read", "-g", "AppleInterfaceStyle"],
                capture_output=True, text=True
            )
            if proc.returncode != 0:
                return False
            return proc.stdout.strip().lower() == "dark"
        except Exception:
            return False

    def _apply_provider_label_theme(self):
        """Applique la bonne couleur au provider_label selon le mode sombre."""
        if not hasattr(self, 'provider_label'):
            return
        # Blanc en mode sombre, bleu sinon
        self.provider_label.config(fg=("white" if self._is_dark_mode else "blue"))

    def _start_theme_watcher(self, interval_ms: int = 2000):
        """Surveille le mode sombre macOS et met à jour la couleur du provider_label si l'état change."""
        def _tick():
            try:
                current = self._is_macos_dark_mode()
                if current != self._is_dark_mode:
                    self._is_dark_mode = current
                    self._apply_provider_label_theme()
            finally:
                # Replanifie la prochaine vérification
                if self.root and self.root.winfo_exists():
                    self.root.after(interval_ms, _tick)
        # Premier tick après interval_ms
        if self.root and self.root.winfo_exists():
            self.root.after(interval_ms, _tick)


    def on_provider_selected(self):
        """Handles selection from the TTS Provider radio button menu."""
        new_provider = self.provider_var.get()
        # Prevent running the switch logic if the selection hasn't actually changed.
        # This can happen if the user cancels the API key dialog.
        if new_provider != self.app_settings.get("tts_provider"):
            self.switch_tts_provider(new_provider)

    def switch_tts_provider(self, provider: str):
        """Switch TTS provider, update settings, and fetch the correct API key."""
        if provider not in ["gemini", "elevenlabs"]:
            return

        # --- NOUVEAU : déclenche quota si ElevenLabs ---
        if provider.lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

        from generate_podcast import get_api_key  # Local import is safe
        provider_title = provider.title()

        # Attempt to get the new API key. This will prompt the user if the key is not found.
        new_api_key = get_api_key(self.log_status, self.logger, parent_window=self.root, service=provider)

        # If the user cancels the key entry dialog, abort the switch.
        if not new_api_key:
            messagebox.showwarning(
                "API Key Required",
                f"Could not set an API key for {provider_title}.\n\n"
                f"The provider has not been switched.",
                parent=self.root
            )
            # Revert the radio button to the previous setting
            self.provider_var.set(self.app_settings.get("tts_provider"))
            self.log_status(f"API key acquisition for {provider_title} failed. Provider switch cancelled.")
            return

        # If successful, update the API key in memory and in the settings.
        self.api_key = new_api_key
        self.app_settings["tts_provider"] = provider
        self.save_settings(self.app_settings)

        # Update UI to reflect the change
        self._update_provider_label() # Update the label to its base state
        self.log_status(f"Successfully switched TTS provider to {provider_title}.")
        if provider == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def update_provider_menu_state(self):
        """
        Met à jour la disponibilité du sous-menu TTS provider en fonction des clés API.
        Le sous-menu n’apparaît que si les 2 clés sont configurées.
        """
        import keyring

        gemini_key_exists = bool(keyring.get_password("PodcastGenerator", "gemini_api_key"))
        elevenlabs_key_exists = bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))

        # (Re)construit le sous-menu dynamiquement
        self.rebuild_tts_provider_menu()

        # Cas limites: si la clé du provider courant a disparu, basculer vers l’autre si possible
        current_provider = self.provider_var.get()
        if current_provider == "gemini" and not gemini_key_exists and elevenlabs_key_exists:
            self.log_status("Gemini API key not found. Switching to ElevenLabs.")
            self.provider_var.set("elevenlabs")
            self.on_provider_selected()
        elif current_provider == "elevenlabs" and not elevenlabs_key_exists and gemini_key_exists:
            self.log_status("ElevenLabs API key not found. Switching to Gemini.")
            self.provider_var.set("gemini")
            self.on_provider_selected()

        # Mettre à jour l'état de "Voice settings..." (activé si au moins une clé)
        self.update_voice_settings_enabled()

    def rebuild_tts_provider_menu(self):
        """
        (Re)construit le sous-menu 'TTS provider' sous Settings uniquement si
        plus d'une clé est configurée (donc Gemini ET ElevenLabs).
        """
        import keyring

        gemini_key_exists = bool(keyring.get_password("PodcastGenerator", "gemini_api_key"))
        elevenlabs_key_exists = bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))
        need_submenu = gemini_key_exists and elevenlabs_key_exists

        existing_index = self._find_menu_index_by_label(self.settings_menu, "TTS provider")

        if need_submenu:
            if existing_index is None:
                # Créer le sous-menu et l'attacher
                self.tts_submenu = tk.Menu(self.settings_menu, tearoff=0)
                self.tts_submenu.add_radiobutton(label="Gemini", variable=self.provider_var, value="gemini",
                                                 command=self.on_provider_selected)
                self.tts_submenu.add_radiobutton(label="ElevenLabs", variable=self.provider_var, value="elevenlabs",
                                                 command=self.on_provider_selected)
                self.settings_menu.add_cascade(label="TTS provider", menu=self.tts_submenu)
            else:
                # Déjà présent: s'assurer que la référence existe
                if self.tts_submenu is None:
                    self.tts_submenu = tk.Menu(self.settings_menu, tearoff=0)
                    self.tts_submenu.add_radiobutton(label="Gemini", variable=self.provider_var, value="gemini",
                                                     command=self.on_provider_selected)
                    self.tts_submenu.add_radiobutton(label="ElevenLabs", variable=self.provider_var, value="elevenlabs",
                                                     command=self.on_provider_selected)
                    self.settings_menu.delete(existing_index)
                    self.settings_menu.insert_cascade(existing_index, label="TTS provider", menu=self.tts_submenu)
        else:
            if existing_index is not None:
                try:
                    self.settings_menu.delete(existing_index)
                except tk.TclError:
                    pass
            self.tts_submenu = None

    def update_voice_settings_enabled(self):
        """Active 'Voice settings...' si au moins une clé API est configurée, sinon désactive."""
        import keyring
        has_any_key = bool(keyring.get_password("PodcastGenerator", "gemini_api_key")) or \
                      bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))
        idx = self._find_menu_index_by_label(self.settings_menu, "Voice settings...")
        if idx is not None:
            self.settings_menu.entryconfig(idx, state='normal' if has_any_key else 'disabled')
            # Protéger l'accès au bouton si l'initialisation n'est pas terminée.
            if hasattr(self, "generate_button") and self.generate_button:
                self.generate_button.config(state='normal' if has_any_key else 'disabled')
        
    def _find_menu_index_by_label(self, menu: tk.Menu, label: str):
        """Retourne l'index d'une entrée de menu par son label, ou None si absent."""
        try:
            end_index = menu.index('end')
            if end_index is None:
                return None
            for i in range(end_index + 1):
                try:
                    if menu.entrycget(i, 'label') == label:
                        return i
                except tk.TclError:
                    continue
        except tk.TclError:
            return None
        return None

    def open_api_keys_window(self):
        """Opens the API keys management window."""
        # Désactiver le menu Settings pendant l'ouverture
        self.menubar.entryconfig("Settings", state="disabled")
        win = APIKeysWindow(self.root, self.on_api_keys_window_close)
        return win

    def on_api_keys_window_close(self):
        """Callback to re-enable the TTS menu when API keys window is closed."""
        self.menubar.entryconfig("Settings", state="normal")
        # Reconstruit dynamiquement le sous-menu selon les clés et met à jour l'état de l'entrée Voice settings
        self.rebuild_tts_provider_menu()
        self.update_provider_menu_state()
        self.update_voice_settings_enabled()
        # Si ElevenLabs est actif, rafraîchir le quota affiché
        if self.app_settings.get("tts_provider", "gemini").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def load_settings(self):
        """Loads settings from the JSON file."""
        try:
            with open(self.settings_filepath, 'r') as f:
                settings = json.load(f)
                # Load the settings as they are, preserving the rich dictionary for ElevenLabs.
                # The data will be flattened only when needed (right before generation).
                tts_provider = settings.get("tts_provider", self.DEFAULT_APP_SETTINGS["tts_provider"])
                speaker_voices = settings.get("speaker_voices", self.DEFAULT_APP_SETTINGS["speaker_voices"].copy())
                speaker_voices_elevenlabs = settings.get("speaker_voices_elevenlabs", self.DEFAULT_APP_SETTINGS["speaker_voices_elevenlabs"].copy())
                elevenlabs_quota_cache = settings.get("elevenlabs_quota_cache", None)
                
                return {
                    "tts_provider": tts_provider,
                    "speaker_voices": speaker_voices,
                    "speaker_voices_elevenlabs": speaker_voices_elevenlabs,
                    "elevenlabs_quota_cache": elevenlabs_quota_cache
                }
        except (FileNotFoundError, json.JSONDecodeError):
            # Returns default app settings if the file does not exist or is corrupt
            return json.loads(json.dumps(self.DEFAULT_APP_SETTINGS))

    def save_settings(self, settings_to_save):
        """Saves the settings to the JSON file."""
        self.app_settings = settings_to_save
        try:
            os.makedirs(self.app_data_dir, exist_ok=True)  # Ensures the directory exists
            with open(self.settings_filepath, 'w') as f:
                json.dump(self.app_settings, f, indent=4)
            #self.log_status("Settings saved successfully.")
        except IOError as e:
            messagebox.showerror("Saving Error", f"Cannot save settings to file:\n{e}", parent=self.root)
            self.logger.error(f"Saving error for settings: {e}")

    def update_elevenlabs_quota_in_status(self):
        """Fetches ElevenLabs quota in a background thread and updates the status label."""
        import keyring
        import threading
        import requests

        key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
        if not key:
            self.elevenlabs_quota_text = None
            # Met à jour le cache (efface s'il n'y a pas de clé)
            self.app_settings["elevenlabs_quota_cache"] = None
            self.save_settings(self.app_settings)
            self.root.after(0, self._update_provider_label) # Update UI to remove old quota
            return

        def _to_int(value):
            try:
                if isinstance(value, (int, float)):
                    return int(value)
                if isinstance(value, str):
                    return int(float(value.strip()))
            except Exception:
                return None
            return None

        def _save_quota_cache(text: str):
            try:
                self.app_settings["elevenlabs_quota_cache"] = {
                    "text": text,
                    "timestamp": datetime.now(datetime.UTC).isoformat().replace("+00:00", "Z")
                }
                self.save_settings(self.app_settings)
            except Exception:
                pass

        def fetch_and_update():
            try:
                headers = {"xi-api-key": key}
                resp = requests.get("https://api.elevenlabs.io/v1/user", headers=headers, timeout=10)
                if resp.status_code != 200:
                    self.elevenlabs_quota_text = "TTS Provider: ElevenLabs - Quota unavailable"
                    self.logger.warning(f"Failed to get ElevenLabs quota, status: {resp.status_code}")
                    _save_quota_cache(self.elevenlabs_quota_text)
                else:
                    data = resp.json()
                    sub = data.get("subscription", {})
                    used = sub.get("character_count")
                    limit = sub.get("character_limit")
                    if isinstance(used, int) and isinstance(limit, int) and limit > 0:
                        remaining = max(0, limit - used)
                        self.elevenlabs_quota_text = f"TTS Provider: ElevenLabs - Remaining: {remaining} / {limit} characters"
                    else:
                        self.elevenlabs_quota_text = "TTS Provider: ElevenLabs - Quota info missing"
                    _save_quota_cache(self.elevenlabs_quota_text)
            except Exception as e:
                self.logger.error(f"Error fetching ElevenLabs quota: {e}", exc_info=True)
                self.elevenlabs_quota_text = "TTS Provider: ElevenLabs - Network error"
                _save_quota_cache(self.elevenlabs_quota_text)
            finally:
                # Always schedule the UI update from the main thread
                self.root.after(0, self._update_provider_label)

        threading.Thread(target=fetch_and_update, daemon=True).start()

    def open_settings_window(self):
        """Opens the settings management window."""
        # Disable the button while the window is open to avoid duplicates
        self.menubar.entryconfig("Settings", state="disabled")
        from settings_window import SettingsWindow
        SettingsWindow(
            self.root,
            current_settings=self.app_settings,
            save_callback=self.save_settings,
            close_callback=self.on_settings_window_close,
            default_settings=self.DEFAULT_APP_SETTINGS,
            preloaded_elevenlabs_voices=self.elevenlabs_voices_cache  # <-- passe le cache
        )

    def show_about_window(self):
        """Displays the 'About' window."""
        AboutWindow(self.root)

    def open_documentation(self):
        """Opens the link to the documentation or the repository."""
        webbrowser.open_new_tab("https://github.com/laurentftech/Podcast_generator")

    def log_status(self, message: str):
        self.log_queue.put(message)

    def poll_log_queue(self):
        # We only process one message at a time to avoid blocking the event loop.
        # This ensures the interface remains responsive and can handle other tasks
        # (like on_generation_complete) between log displays.
        try:
            message = self.log_queue.get_nowait()
            if isinstance(message, tuple):
                msg_type = message[0]
                if msg_type == 'GENERATION_COMPLETE':
                    self.on_generation_complete(success=message[1])
                elif msg_type == 'UPDATE_PLAY_BUTTON':
                    self.play_button.config(text=message[1], state=message[2])
            else:
                self._update_log(message)
        except queue.Empty:
            pass  # The queue is empty, do nothing
        self.root.after(100, self.poll_log_queue)  # Check the queue every 100 ms

    def _update_log(self, message):
        self.log_text.config(state='normal')
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)
        self.log_text.config(state='disabled')

    def clear_log(self):
        """Clears the log text area."""
        self.log_text.config(state='normal')
        self.log_text.delete('1.0', tk.END)
        self.log_text.config(state='disabled')

    def load_script_from_file(self):
        """Opens a dialog to load a .txt file into the script area."""
        filepath = filedialog.askopenfilename(
            title="Open a script file",
            filetypes=(("Text files", "*.txt"), ("All files", "*.*"))
        )
        if not filepath:
            return

        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                self.script_text.delete('1.0', tk.END)
                self.script_text.insert('1.0', f.read())
            self.log_status(f"Script loaded from: {os.path.basename(filepath)}")
        except Exception as e:
            messagebox.showerror("Reading error", f"Cannot read the file:\n{e}")
            self.logger.error(f"Error reading the script: {e}")

    def start_generation_thread(self):
        """Starts the generation in a separate thread to avoid freezing the UI."""
        script_content = self.script_text.get("1.0", tk.END).strip()
        if not script_content:
            messagebox.showwarning("Empty script", "Please enter or load a script before starting generation.",
                                   parent=self.root)
            return

        # --- Validate Speaker Voices ---
        try:
            missing_speakers, configured_speakers = validate_speakers(script_content, self.app_settings)
        except ValueError as e:
            # Règle Gemini: plus de 2 speakers -> erreur bloquante
            messagebox.showerror("Configuration Error", str(e), parent=self.root)
            return

        if missing_speakers:
            missing_speakers_str = ", ".join(missing_speakers)
            configured_str = ", ".join(configured_speakers) if configured_speakers else "None"
            messagebox.showerror(
                "Configuration Error",
                f"The following speakers from the script do not have an assigned voice:\n\n"
                f"Missing speakers: {missing_speakers_str}\n\n"
                f"Configured speakers: {configured_str}\n\n"
                f"Please configure their voices in 'Options -> Voice Settings' before continuing.",
                parent=self.root
            )
            return

        # Ask the user where to save the output file
        output_filepath = filedialog.asksaveasfilename(
            title="Save podcast as...",
            defaultextension=".mp3",
            filetypes=(
                ("MP3", "*.mp3"),
                ("WAV", "*.wav"),
                ("All files", "*.*")
            ),
            initialdir=os.path.expanduser("~/Downloads"),
        )

        if not output_filepath:
            self.log_status("Generation cancelled by user.")
            return

        # Disable buttons during generation
        self.generate_button.config(state='disabled')
        self.load_button.config(state='disabled')
        self.play_button.config(state='disabled')
        self.show_button.config(state='disabled')
        self.menubar.entryconfig("Settings", state="disabled")

        # Show and start the progress bar
        self.clear_log()

        self.progress_bar.pack(fill=tk.X, pady=(10, 0), before=self.button_frame)
        self.progress_bar.start()

        thread = threading.Thread(
            target=self.run_generation,
            args=(script_content, output_filepath, self.app_settings, self.api_key)
        )
        thread.daemon = True
        thread.start()

    def run_generation(self, script_content, output_filepath, app_settings, api_key):
        """The function executed by the thread."""
        
        # --- Data Sanitization ---
        # Create a "clean" version of app_settings for the backend.
        # This ensures we only pass the voice ID to ElevenLabs, not the whole object.
        app_settings_clean = {
            "tts_provider": app_settings.get("tts_provider"),
            "speaker_voices": app_settings.get("speaker_voices", {})
        }
        
        # Nettoyage des voix Gemini: convertir "Name - Desc" -> "Name"
        gemini_clean = {}
        try:
            for speaker, voice in app_settings_clean.get("speaker_voices", {}).items():
                if isinstance(voice, str) and " - " in voice:
                    gemini_clean[speaker] = voice.split(" - ", 1)[0].strip()
                else:
                    gemini_clean[speaker] = voice
        except Exception:
            gemini_clean = app_settings_clean.get("speaker_voices", {})
        app_settings_clean["speaker_voices"] = gemini_clean

        elevenlabs_mapping_clean = {}
        elevenlabs_mapping_raw = app_settings.get("speaker_voices_elevenlabs", {})
        for speaker, data in elevenlabs_mapping_raw.items():
            if isinstance(data, dict):
                # New format: extract just the ID
                elevenlabs_mapping_clean[speaker] = data.get('id', '')
            else:
                # Legacy format: use the string as-is
                elevenlabs_mapping_clean[speaker] = data
        
        app_settings_clean["speaker_voices_elevenlabs"] = elevenlabs_mapping_clean
        # --- End of Data Sanitization ---

        generated_filepath = None
        try:
            self.logger.info("Starting generation thread.")
            self.log_status(f"Starting generation to '{os.path.basename(output_filepath)}'...")
            generated_filepath = self.generate_func(
                script_text=script_content,
                app_settings=app_settings_clean,  # Pass the clean version
                output_filepath=output_filepath,
                status_callback=self.log_status,
                api_key=api_key
            )
            if generated_filepath:
                self.last_generated_filepath = generated_filepath
                self.logger.info(f"Generation completed successfully. File: {generated_filepath}")
                self.log_status(
                    f"\n--- Generation completed successfully! File: {os.path.basename(generated_filepath)} ---")
            else:
                self.logger.warning("Generation function completed without returning a file path.")
                self.log_status("\n--- Generation failed. Please check the logs. ---")
        except Exception as e:
            self.logger.error(f"Unhandled error in generation thread: {e}", exc_info=True)
            self.log_status(f"A critical error occurred in the thread: {e}")
            generated_filepath = None  # Ensure the status is 'failure'
        finally:
            # We use the queue, our reliable communication channel,
            # to signal the end of the generation and its status (success/failure).
            success = bool(generated_filepath)
            self.log_queue.put(('GENERATION_COMPLETE', success))

    def on_generation_complete(self, success: bool):
        if success:
            self.root.bell()
            if self.ffplay_path:
                self.show_button.config(state='normal')
                self.play_button.config(state='normal')
            if self.app_settings.get("tts_provider").lower() == "elevenlabs":
                self.update_elevenlabs_quota_in_status()

        self.progress_bar.stop()
        self.generate_button.config(state='normal')
        self.load_button.config(state='normal')
        self.menubar.entryconfig("Settings", state="normal")
        if self.progress_bar.winfo_ismapped():
            self.progress_bar.pack_forget()
        self.log_text.config(state='disabled')  # Disable the log area at the very end

    def open_file_location(self):
        """Opens the folder containing the last generated file and selects it."""
        if not self.last_generated_filepath or not os.path.exists(self.last_generated_filepath):
            messagebox.showerror("File not found", "The generated audio file was not found or is no longer accessible.")
            return

        try:
            if sys.platform == "darwin":  # macOS
                # 'open -R' reveals the file in Finder
                subprocess.run(["open", "-R", self.last_generated_filepath], check=True)
            elif sys.platform == "win32":  # Windows
                # For explorer.exe, it's more reliable to use shell=True and pass
                # the command as a string, with the path properly quoted.
                filepath = os.path.normpath(self.last_generated_filepath)
                subprocess.run(f'explorer /select,"{filepath}"', shell=True)
            else:  # Linux and others (opens the containing folder)
                subprocess.run(["xdg-open", os.path.dirname(self.last_generated_filepath)], check=True)
        except (FileNotFoundError, subprocess.CalledProcessError) as e:
            messagebox.showerror("Error", f"Unable to open the file manager.\n"
                                          f"Check that system tools are accessible.\n\nError: {e}")

    def play_last_generated_file(self):
        """Plays or stops the playback of the last generated audio file."""
        if self.playback_obj and self.playback_obj.poll() is None:
            self.playback_obj.terminate()  # Stops the ffplay process if running
            return

        if not self.ffplay_path:
            messagebox.showerror(
                "Audio player not found",
                "The 'ffplay' command (part of FFmpeg) was not found.\n\n"
                "Playback is disabled. Please ensure FFmpeg is properly installed."
            )
            self.play_button.config(state='disabled')
            return

        if not self.last_generated_filepath or not os.path.exists(self.last_generated_filepath):
            messagebox.showerror("File not found", "The generated audio file was not found or is no longer accessible.")
            return

        threading.Thread(target=self._play_in_thread, daemon=True).start()

    def _play_in_thread(self):
        """The playback function executed in a separate thread."""
        try:
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW

            self.log_queue.put(('UPDATE_PLAY_BUTTON', '⏹️ Stop', 'normal'))
            command = [self.ffplay_path, "-nodisp", "-autoexit", "-loglevel", "quiet", self.last_generated_filepath]
            self.playback_obj = subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                                 creationflags=creation_flags)
            self.playback_obj.wait()
        except Exception as e:
            self.logger.error(f"Audio playback error with ffplay: {e}", exc_info=True)
            self.log_status(f"Audio playback error: {e}")
        finally:
            self.playback_obj = None
            if self.root.winfo_exists():
                self.log_queue.put(('UPDATE_PLAY_BUTTON', '▶️ Play', 'normal'))

    def on_settings_window_close(self):
        self.menubar.entryconfig("Settings", state="normal")
        self._update_provider_label()
        self.provider_var.set(self.app_settings.get("tts_provider", "gemini").lower())
        self.update_provider_menu_state()
        if self.app_settings.get("tts_provider", "").lower() == "elevenlabs":
            self.update_elevenlabs_quota_in_status()

    def _update_provider_label(self):
        """Updates the provider label based on the current provider and cached quota text."""
        current_provider_raw = self.app_settings.get("tts_provider", "gemini")
        current_provider_display = current_provider_raw.title()
        text_to_display = f"TTS Provider: {current_provider_display}"
        
        # Si ElevenLabs est actif et qu’un quota est connu, afficher le quota
        if current_provider_raw.lower() == "elevenlabs" and self.elevenlabs_quota_text:
            text_to_display = self.elevenlabs_quota_text
        
        if hasattr(self, 'provider_label'):
            self.provider_label.config(text=text_to_display)

    def _schedule_provider_label_refresh(self, delay_ms=2000, retries=5):
        """Planifie des rafraîchissements du provider_label après un délai, avec quelques tentatives."""
        def _try_refresh(attempt=1):
            # Met à jour le label avec l’info la plus récente disponible
            self._update_provider_label()
            # Si ElevenLabs est actif et que le quota n'est pas encore connu, retente plus tard
            if (
                attempt < retries
                and self.app_settings.get("tts_provider", "gemini").lower() == "elevenlabs"
                and not self.elevenlabs_quota_text
            ):
                self.root.after(delay_ms, lambda: _try_refresh(attempt + 1))
        # Premier essai après delay_ms
        self.root.after(delay_ms, _try_refresh)


class APIKeysWindow(tk.Toplevel):
    def __init__(self, parent, close_callback):
        super().__init__(parent)
        self.title("Welcome to Podcast Generator!")
        self.transient(parent)
        self.grab_set()
        self.resizable(False, False)
        self.close_callback = close_callback
        self.protocol("WM_DELETE_WINDOW", self.on_close)

        main_frame = tk.Frame(self, padx=20, pady=15)
        main_frame.pack(fill=tk.BOTH, expand=True)

        tk.Label(main_frame, text="Manage API Keys", font=('Helvetica', 12, 'bold')).pack(pady=(0, 15))
        # Message de bienvenue (en anglais) pour guider l’utilisateur
        welcome_text = (
            "Welcome!\n"
            "Podcast Generator is a tool that generates podcasts using AI.\n"
            "To use it, you need to configure at least one API key for TTS (Text-to-Speech).\n"
            "You can set your Google Gemini or ElevenLabs API key below. They will be stored securely in your system.\n"
        )
        tk.Label(
            main_frame,
            text=welcome_text,
            justify="left",
            wraplength=520
        ).pack(anchor="w", pady=(0, 12))

        # Gemini API Key section
        gemini_frame = tk.LabelFrame(main_frame, text="Google Gemini API", padx=10, pady=10)
        gemini_frame.pack(fill=tk.X, pady=(0, 10))

        # Lien cliquable vers la page pour obtenir la clé Gemini
        gemini_link = tk.Label(gemini_frame, text="Get a Gemini API key", fg="blue", cursor="hand2")
        gemini_link.pack(anchor="w", pady=(0, 6))
        gemini_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://aistudio.google.com/app/apikey"))
        self.gemini_status_label = tk.Label(gemini_frame, text="", fg="green")
        self.gemini_status_label.pack(anchor="w", pady=(0, 5))

        gemini_button_frame = tk.Frame(gemini_frame)
        gemini_button_frame.pack(fill=tk.X)

        tk.Button(gemini_button_frame, text="Set/Update Key", command=lambda: self.set_api_key("gemini")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(gemini_button_frame, text="Remove Key", command=lambda: self.remove_api_key("gemini")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(gemini_button_frame, text="Test Key", command=lambda: self.test_api_key("gemini")).pack(side=tk.LEFT)

        # ElevenLabs API Key section
        elevenlabs_frame = tk.LabelFrame(main_frame, text="ElevenLabs API", padx=10, pady=10)
        elevenlabs_frame.pack(fill=tk.X, pady=(0, 10))

        # Note sur les permissions minimales requises
        tk.Label(
            elevenlabs_frame,
            text="Minimum required permissions in ElevenLabs API settings:\n"
                 "• Text to Speech: Has access\n"
                 "• User: Read only\n"
                 "• Voices: Read only",
            justify="left",
            wraplength=520
        ).pack(anchor="w", pady=(0, 6))
        # Lien cliquable vers la page pour obtenir la clé ElevenLabs
        elevenlabs_link = tk.Label(elevenlabs_frame, text="Get an ElevenLabs API key", fg="blue", cursor="hand2")
        elevenlabs_link.pack(anchor="w", pady=(0, 6))
        elevenlabs_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://elevenlabs.io/app/subscription"))

        self.elevenlabs_status_label = tk.Label(elevenlabs_frame, text="", fg="green")
        self.elevenlabs_status_label.pack(anchor="w", pady=(0, 5))

        elevenlabs_button_frame = tk.Frame(elevenlabs_frame)
        elevenlabs_button_frame.pack(fill=tk.X)

        tk.Button(elevenlabs_button_frame, text="Set/Update Key", command=lambda: self.set_api_key("elevenlabs")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(elevenlabs_button_frame, text="Remove Key", command=lambda: self.remove_api_key("elevenlabs")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(elevenlabs_button_frame, text="Test Key", command=lambda: self.test_api_key("elevenlabs")).pack(
            side=tk.LEFT)

        # Close button
        tk.Button(main_frame, text="Close", command=self.on_close).pack(pady=(15, 0))

        # Update status on window creation
        self.update_status()

    def update_status(self):
        """Update the status labels for both APIs."""
        import keyring

        # Check Gemini key
        gemini_key = keyring.get_password("PodcastGenerator", "gemini_api_key")
        if gemini_key:
            self.gemini_status_label.config(text="✓ API key is configured", fg="green")
        else:
            self.gemini_status_label.config(text="✗ No API key configured", fg="red")

        # Check ElevenLabs key
        elevenlabs_key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
        if elevenlabs_key:
            self.elevenlabs_status_label.config(text="✓ API key is configured", fg="green")
        else:
            self.elevenlabs_status_label.config(text="✗ No API key configured", fg="red")

    def set_api_key(self, service: str):
        """Set or update an API key for the specified service."""
        import keyring
        from tkinter import simpledialog

        if service == "elevenlabs":
            title = "ElevenLabs API Key"
            prompt = "Enter your ElevenLabs API key:"
            account = "elevenlabs_api_key"
        else:
            title = "Gemini API Key"
            prompt = "Enter your Google Gemini API key:"
            account = "gemini_api_key"

        new_key = simpledialog.askstring(title, prompt, parent=self, show="*")
        if new_key and new_key.strip():
            keyring.set_password("PodcastGenerator", account, new_key.strip())
            messagebox.showinfo("Success", f"{title} has been saved securely.", parent=self)
            self.update_status()
        elif new_key is not None:  # User clicked OK but entered empty key
            messagebox.showwarning("Invalid Key", "API key cannot be empty.", parent=self)

    def remove_api_key(self, service: str):
        """Remove an API key for the specified service."""
        import keyring

        if service == "elevenlabs":
            title = "ElevenLabs API Key"
            account = "elevenlabs_api_key"
        else:
            title = "Gemini API Key"
            account = "gemini_api_key"

        if messagebox.askyesno("Confirm Removal", f"Are you sure you want to remove the {title}?", parent=self):
            try:
                keyring.delete_password("PodcastGenerator", account)
                messagebox.showinfo("Success", f"{title} has been removed.", parent=self)
            except keyring.errors.PasswordDeleteError:
                messagebox.showinfo("Info", f"No {title} was stored.", parent=self)
            self.update_status()

    def test_api_key(self, service: str):
        """Test an API key for the specified service."""
        import keyring
        import requests
        from google import genai
        
        if service == "elevenlabs":
            key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
            if not key:
                messagebox.showwarning("No Key", "No ElevenLabs API key is configured.", parent=self)
                return
            
            # Test ElevenLabs API
            try:
                headers = {"xi-api-key": key}
                response = requests.get("https://api.elevenlabs.io/v1/user", headers=headers, timeout=10)
                if response.status_code == 200:
                    user_data = response.json()
                    subscription = user_data.get('subscription', {}).get('tier', 'Unknown')
                    messagebox.showinfo("Success", f"ElevenLabs API key is valid!\n\nSubscription: {subscription}.\n Usage: {user_data.get('subscription', {}).get('character_count', 'Unknown')} / {user_data.get('subscription', {}).get('character_limit', 'Unknown')} characters.", parent=self)
                elif response.status_code == 401:
                    try:
                        error_detail = response.json().get('detail', {})
                        if isinstance(error_detail, dict):
                            error_msg = error_detail.get('message', 'Invalid API key')
                        else:
                            error_msg = str(error_detail)
                    except:
                        error_msg = "Invalid or expired API key"
                    
                    messagebox.showerror("Authentication Error", 
                                       f"ElevenLabs API key test failed (401 Unauthorized):\n\n"
                                       f"{error_msg}\n\n"
                                       f"Please check:\n"
                                       f"• Key is correct and complete\n"
                                       f"• Key hasn't expired\n"
                                       f"• Account is active on elevenlabs.io", parent=self)
                else:
                    try:
                        error_detail = response.json()
                        error_msg = str(error_detail)
                    except:
                        error_msg = response.text[:200] if response.text else "Unknown error"
                    
                    messagebox.showerror("Error", 
                                       f"ElevenLabs API key test failed: {response.status_code}\n\n"
                                       f"Details: {error_msg}", parent=self)
            except requests.exceptions.RequestException as e:
                messagebox.showerror("Network Error", f"Failed to connect to ElevenLabs API:\n{str(e)}", parent=self)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to test ElevenLabs API key: {str(e)}", parent=self)
        
        else:
            key = keyring.get_password("PodcastGenerator", "gemini_api_key")
            if not key:
                messagebox.showwarning("No Key", "No Gemini API key is configured.", parent=self)
                return
            
            # Test Gemini API
            try:
                client = genai.Client(api_key=key)
                # Simple test request
                models = list(client.models.list())
                if models:
                    messagebox.showinfo("Success", f"Gemini API key is valid!", parent=self)
                else:
                    messagebox.showwarning("Warning", "Gemini API key appears valid but no models accessible.", parent=self)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to test Gemini API key: {str(e)}", parent=self)

    def on_close(self):
        """Handle window closing."""
        self.close_callback()
        self.destroy()


# ... existing code ...

class AboutWindow(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("About Podcast Generator")
        self.transient(parent)
        self.grab_set()
        self.resizable(False, False)

        main_frame = tk.Frame(self, padx=20, pady=15)
        main_frame.pack(fill=tk.BOTH, expand=True)

        tk.Label(main_frame, text=f"Podcast Generator v{get_app_version()}", font=('Helvetica', 12, 'bold')).pack(
            pady=(0, 5))
        tk.Label(main_frame, text=f"Copyright (c) {datetime.now().year} Laurent FRANCOISE").pack()
        tk.Label(main_frame, text="Licence : MIT License").pack(pady=(0, 15))

        support_frame = tk.LabelFrame(main_frame, text="Support the projet", padx=10, pady=10)
        support_frame.pack(fill=tk.X, pady=(0, 10))

        tk.Label(support_frame, text="If this application is useful to you, you can support its development:").pack(
            pady=(0, 5))

        coffee_link = tk.Label(support_frame, text="❤️ Buy Me a Coffee", fg="blue", cursor="hand2",
                               font=('Helvetica', 10, 'bold'))
        coffee_link.pack(pady=(0, 5))
        coffee_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://buymeacoffee.com/laurentftech"))

        credits_frame = tk.LabelFrame(main_frame, text="Credits and Acknowledgements", padx=10, pady=10)
        credits_frame.pack(fill=tk.X, pady=(0, 10))

        # Gemini API link
        gemini_frame = tk.Frame(credits_frame)
        gemini_frame.pack(fill=tk.X, pady=2)
        tk.Label(gemini_frame, text="- Google Gemini API:").pack(side=tk.LEFT)
        link_label = tk.Label(gemini_frame, text="ai.google.dev/gemini-api", fg="blue", cursor="hand2")
        link_label.pack(side=tk.LEFT, padx=5)
        link_label.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://ai.google.dev/gemini-api"))

        # ElevenLabs API link
        elevenlabs_frame = tk.Frame(credits_frame)
        elevenlabs_frame.pack(fill=tk.X, pady=2)
        tk.Label(elevenlabs_frame, text="- ElevenLabs API:").pack(side=tk.LEFT)
        link_label2 = tk.Label(elevenlabs_frame, text="elevenlabs.io", fg="blue", cursor="hand2")
        link_label2.pack(side=tk.LEFT, padx=5)
        link_label2.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://elevenlabs.io"))

        tk.Label(credits_frame, text="- Tkinter for the graphical interface", anchor="w").pack(fill=tk.X, pady=2)

        # Flaticon link
        flaticon_frame = tk.Frame(credits_frame)
        flaticon_frame.pack(fill=tk.X, pady=2)
        tk.Label(flaticon_frame, text="- Icon by Smashicons from").pack(side=tk.LEFT)
        flaticon_link = tk.Label(flaticon_frame, text="flaticon.com", fg="blue", cursor="hand2")
        flaticon_link.pack(side=tk.LEFT, padx=5)
        flaticon_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://www.flaticon.com"))

        ok_button = tk.Button(main_frame, text="OK", command=self.destroy, width=10)
        ok_button.pack(pady=(10, 0))

        self.bind('<Return>', lambda event: ok_button.invoke())
        self.protocol("WM_DELETE_WINDOW", self.destroy)

def open_settings_window(self):
        """Opens the settings management window."""
        # Disable the button while the window is open to avoid duplicates
        self.menubar.entryconfig("Settings", state="disabled")
        from settings_window import SettingsWindow
        SettingsWindow(
            self.root,
            current_settings=self.app_settings,
            save_callback=self.save_settings,
            close_callback=self.on_settings_window_close,
            default_settings=self.DEFAULT_APP_SETTINGS,
            preloaded_elevenlabs_voices=self.elevenlabs_voices_cache  # <-- passe le cache
        )

def main():
    # Initializes the application and starts the main Tkinter loop
    # Creates the root window but hides it for now.
    # This allows for reliable display of error dialogs
    # even if the full interface initialization fails.
    root = tk.Tk()
    root.withdraw()

    # --- Import path correction ---
    # Ensures the script can find 'generate_podcast.py'
    # regardless of where it is executed from.
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        if script_dir not in sys.path:
            sys.path.insert(0, script_dir)
    except NameError:
        # __file__ is not defined in some interactive environments
        pass

    # --- Importing dependencies ---
    try:
        from generate_podcast import generate, PODCAST_SCRIPT, setup_logging, find_ffplay_path
        # Note: on n'importe plus get_api_key ici pour remplacer la saisie par la fenêtre de gestion des clés.
    except ImportError as e:
        messagebox.showerror(
            "Import Error",
            f"The file 'generate_podcast.py' was not found.\n\n"
            f"Please ensure it is in the same folder as gui.py.\n\n"
            f"Error details: {e}"
            , parent=root)
        root.destroy()
        return

    # Initializes logging before anything else
    logger = setup_logging()

    # Create the app instance first, which populates the root window with widgets.
    # The window remains hidden for now. We pass a placeholder for the api_key.
    app = PodcastGeneratorApp(root, generate_func=generate, logger=logger, api_key="", default_script=PODCAST_SCRIPT)

    # --- API key check at startup (remplace l'ancien get_api_key) ---
    import keyring
    current_provider = app.app_settings.get("tts_provider", "gemini")
    account_name = "elevenlabs_api_key" if current_provider == "elevenlabs" else "gemini_api_key"
    api_key = keyring.get_password("PodcastGenerator", account_name)

    if not api_key:
        # Ouvrir directement la fenêtre de gestion des clés et attendre sa fermeture
        win = app.open_api_keys_window()
        root.deiconify()  # s'assurer que la fenêtre parent est visible
        root.wait_window(win)

        # Re-vérifier la clé après fermeture
        api_key = keyring.get_password("PodcastGenerator", account_name)
        if not api_key:
            logger.info("Application closed because no API key was provided at startup.")
            messagebox.showwarning("API Key Required", "The application cannot start without an API key.", parent=root)
            root.destroy()
            return

    # Now that we have the key, assign it to the app and show the main window.
    app.api_key = api_key
    # Met à jour immédiatement l'état des contrôles dépendants des clés
    app.update_provider_menu_state()
    app.update_voice_settings_enabled()

    # Précharger les voix ElevenLabs au démarrage (si la clé est configurée)
    def _prefetch_elevenlabs():
        try:
            import keyring, requests
            key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
            if not key:
                app.elevenlabs_voices_cache = []
                return
            headers = {"xi-api-key": key}
            resp = requests.get("https://api.elevenlabs.io/v1/voices", headers=headers, timeout=15)
            if resp.status_code != 200:
                app.elevenlabs_voices_cache = []
                return
            data = resp.json()
            voices = []
            for voice in data.get('voices', []):
                voice_id = voice.get('voice_id', '')
                name = voice.get('name', 'Unknown')
                category = voice.get('category', '')
                labels = voice.get('labels', {}) if voice.get('labels') else {}
                accent = labels.get('accent', '') if isinstance(labels, dict) else ''
                age = labels.get('age', '') if isinstance(labels, dict) else ''
                gender = labels.get('gender', '') if isinstance(labels, dict) else ''
                desc_parts = []
                if gender: desc_parts.append(str(gender).title())
                if age: desc_parts.append(str(age).title())
                if accent: desc_parts.append(str(accent))
                description = ', '.join(desc_parts) if desc_parts else str(category).title()
                display_name = f"{name} - {description}" if description else name
                voices.append({
                    'id': voice_id,
                    'name': name,
                    'display_name': display_name,
                    'category': category,
                    'labels': labels
                })
            voices.sort(key=lambda x: x.get('name', ''))
            app.elevenlabs_voices_cache = voices
        except Exception:
            app.elevenlabs_voices_cache = []

    import threading as _th
    _th.Thread(target=_prefetch_elevenlabs, daemon=True).start()

    root.deiconify()
    root.mainloop()


if __name__ == "__main__":
    main()
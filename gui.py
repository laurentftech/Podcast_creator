import tkinter as tk
from tkinter import scrolledtext, filedialog, messagebox, ttk
import threading
import os
import subprocess
import sys
import queue
import json
import webbrowser
from datetime import datetime
from typing import Optional, Dict
from generate_podcast import validate_speakers  # Importez la nouvelle fonction

# --- Versioning ---
# This file is automatically generated by setuptools-scm
from _version import __version__

AVAILABLE_VOICES = {
    "Zephyr": "Bright",
    "Puck": "Upbeat",
    "Charon": "Informative",
    "Kore": "Firm",
    "Fenrir": "Excitable",
    "Leda": "Youthful",
    "Orus": "Firm",
    "Aoede": "Breezy",
    "Callirrhoe": "Easy-going",
    "Autonoe": "Bright",
    "Enceladus": "Breathy",
    "Iapetus": "Clear",
    "Umbriel": "Easy-going",
    "Algieba": "Smooth",
    "Despina": "Smooth",
    "Erinome": "Clear",
    "Algenib": "Gravelly",
    "Rasalgethi": "Informative",
    "Laomedeia": "Upbeat",
    "Achernar": "Soft",
    "Alnilam": "Firm",
    "Schedar": "Even",
    "Gacrux": "Mature",
    "Pulcherrima": "Forward",
    "Achird": "Friendly",
    "Zubenelgenubi": "Casual",
    "Vindemiatrix": "Gentle",
    "Sadachbia": "Lively",
    "Sadaltager": "Knowledgeable",
    "Sulafat": "Warm"
}


def get_app_version() -> str:
    """Gets the application version from the _version.py file."""
    return __version__


def get_asset_path(filename: str) -> Optional[str]:
    """
    Gets the absolute path to an asset, handling running from source and from
    a PyInstaller bundle.
    """
    if getattr(sys, 'frozen', False):
        # The application is frozen (packaged with PyInstaller)
        bundle_dir = sys._MEIPASS
    else:
        # The application is running in a normal Python environment
        bundle_dir = os.path.dirname(os.path.abspath(__file__))

    path = os.path.join(bundle_dir, filename)
    return path if os.path.exists(path) else None


class PodcastGeneratorApp:
    DEFAULT_SPEAKER_SETTINGS = {"John": "Schedar", "Samantha": "Zephyr"}
    DEFAULT_APP_SETTINGS = {
        "tts_provider": "gemini",
        "speaker_voices": {"John": "Schedar", "Samantha": "Zephyr"},
        "speaker_voices_elevenlabs": {
            "John": {"id": "pqHfZKP75CvOlQylNhV4", "display_name": "Bill - Male, Old, american"},
            "Samantha": {"id": "Xb7hH8MSUJpSbSDYk0k2", "display_name": "Alice - Female, Middle_Aged, british"}
        }
    }

    def __init__(self, root: tk.Tk, generate_func, logger, api_key: str, default_script: str = ""):
        self.root = root
        self.root.title(f"Podcast Generator v{get_app_version()}")
        self.root.geometry("960x700")
        # --- Application Icon ---
        icon_path = get_asset_path("podcast.png")
        if icon_path:
            try:
                img = tk.PhotoImage(file=icon_path)
                self.root.tk.call('wm', 'iconphoto', self.root._w, img)
            except tk.TclError:
                # In case of format error, continue without icon
                pass

        # --- Define configuration paths ---
        from generate_podcast import get_app_data_dir, find_ffplay_path  # Local import
        self.app_data_dir = get_app_data_dir()
        self.settings_filepath = os.path.join(self.app_data_dir, "settings.json")

        self.generate_func = generate_func
        self.logger = logger
        self.api_key = api_key
        self.log_queue = queue.Queue()
        self.playback_obj = None  # To keep a reference to the playback process
        self.last_generated_filepath = None
        self.ffplay_path = find_ffplay_path()

        self.app_settings = self.load_settings()

        # --- Create a StringVar for the TTS Provider ---
        self.provider_var = tk.StringVar(value=self.app_settings.get("tts_provider", "gemini"))
        # Cache des voix ElevenLabs préchargées
        self.elevenlabs_voices_cache = []

        # --- Menu Bar (Platform-specific) ---
        self.menubar = tk.Menu(self.root)
        self.root.config(menu=self.menubar)

        if sys.platform == "darwin":  # macOS
            try:
                # Create the special "app" menu. This can fail on non-native Tcl/Tk.
                app_menu = tk.Menu(self.menubar, name='apple', tearoff=0)
                self.menubar.add_cascade(label="Podcast Generator", menu=app_menu)

                app_menu.add_command(label=f"About Podcast Generator", command=self.show_about_window)
                app_menu.add_separator()
                app_menu.add_command(label="Voice settings...", command=self.open_settings_window,
                                     accelerator="Command+,")
                app_menu.add_separator()
                # Add standard macOS services for a native feel
                app_menu.add_command(label="Services", role="services")
                app_menu.add_separator()
                app_menu.add_command(label="Hide Podcast Generator", accelerator="Command+H", role="hide")
                app_menu.add_command(label="Hide Others", accelerator="Command+Option+H", role="hideothers")
                app_menu.add_command(label="Show All", role="unhide")
                app_menu.add_separator()
                app_menu.add_command(label="Quit Podcast Generator", accelerator="Command+Q", role="quit")
            except tk.TclError:
                # Fallback for older Tcl/Tk. Clear any partially created menu.
                self.menubar.delete(0, 'end')
                # (Le menu Settings sera créé plus bas, commun à toutes les plateformes)
        # Création du menu Settings (commun à toutes les plateformes)
        self.settings_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Settings", menu=self.settings_menu)

        # Entrées du menu Settings: Voice settings
        self.settings_menu.add_command(label="Voice settings...", command=self.open_settings_window)

        # Sélection du provider TTS (fusion de l'ancien menu "TTS Provider")
        self.settings_menu.add_separator()
        self.settings_menu.add_radiobutton(label="Gemini", variable=self.provider_var, value="gemini",
                                           command=self.on_provider_selected)
        self.settings_menu.add_radiobutton(label="ElevenLabs", variable=self.provider_var, value="elevenlabs",
                                           command=self.on_provider_selected)

        # Gestion des clés API
        self.settings_menu.add_separator()
        self.settings_menu.add_command(label="Manage API Keys...", command=self.open_api_keys_window)

        # Quit (pour Windows/Linux; sur macOS l'app menu expose déjà Quit)
        if sys.platform != "darwin":
            self.settings_menu.add_separator()
            self.settings_menu.add_command(label="Quit", command=self.root.quit)

        # Help Menu (common to all platforms)
        help_menu = tk.Menu(self.menubar, tearoff=0)
        self.menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Documentation (Github)...", command=self.open_documentation)
        help_menu.add_command(label="About...", command=self.show_about_window)
        self.logger.info("Main interface initialized.")

        self.poll_log_queue()
        self.update_provider_menu_state()

        # --- Main Frame ---
        main_frame = tk.Frame(root, padx=10, pady=10)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # --- TTS Provider Status Bar ---
        status_frame = tk.Frame(main_frame, relief=tk.SUNKEN, bd=1)
        status_frame.pack(fill=tk.X, pady=(0, 5))

        current_provider = self.app_settings.get("tts_provider", "gemini").title()
        self.provider_label = tk.Label(status_frame, text=f"TTS Provider: {current_provider}", font=('Helvetica', 9),
                                       fg="blue")
        self.provider_label.pack(side=tk.LEFT, padx=5, pady=2)

        # --- Script Text Area ---
        script_frame = tk.LabelFrame(main_frame, text="Script to read", padx=5, pady=5)
        script_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))

        self.script_text = scrolledtext.ScrolledText(script_frame, wrap=tk.WORD, height=15, width=80)
        self.script_text.pack(fill=tk.BOTH, expand=True)
        self.script_text.insert(tk.END, default_script)

        # --- Log/Status Area ---
        log_frame = tk.LabelFrame(main_frame, text="Generation status", padx=5, pady=5)
        log_frame.pack(fill=tk.BOTH, expand=True)

        self.log_text = scrolledtext.ScrolledText(log_frame, wrap=tk.WORD, height=10, state='disabled')
        self.log_text.pack(fill=tk.BOTH, expand=True)

        # --- Progress Bar (initially hidden) ---
        self.progress_bar = ttk.Progressbar(main_frame, mode='indeterminate')

        # --- Button Frame ---
        self.button_frame = tk.Frame(main_frame)
        self.button_frame.pack(fill=tk.X, pady=(10, 0))

        # Define a common width for visual consistency
        common_button_width = 22

        # --- Left-aligned buttons ---
        self.load_button = tk.Button(self.button_frame, text="Load a script (.txt)", command=self.load_script_from_file,
                                     width=common_button_width)
        self.load_button.pack(side=tk.LEFT, padx=(0, 5))

        self.generate_button = tk.Button(self.button_frame, text="Start generation",
                                         command=self.start_generation_thread, width=common_button_width)
        self.generate_button.pack(side=tk.LEFT)

        # --- Right-aligned buttons (packed in reverse order for correct display) ---
        self.show_button = tk.Button(self.button_frame, text="Open file location", command=self.open_file_location,
                                     state='disabled', width=common_button_width)
        self.show_button.pack(side=tk.RIGHT, padx=(5, 0))

        self.play_button = tk.Button(self.button_frame, text="▶️ Play", command=self.play_last_generated_file,
                                     state='disabled', width=common_button_width)
        self.play_button.pack(side=tk.RIGHT)

    def on_provider_selected(self):
        """Handles selection from the TTS Provider radio button menu."""
        new_provider = self.provider_var.get()
        # Prevent running the switch logic if the selection hasn't actually changed.
        # This can happen if the user cancels the API key dialog.
        if new_provider != self.app_settings.get("tts_provider"):
            self.switch_tts_provider(new_provider)

    def switch_tts_provider(self, provider: str):
        """Switch TTS provider, update settings, and fetch the correct API key."""
        if provider not in ["gemini", "elevenlabs"]:
            return

        from generate_podcast import get_api_key  # Local import is safe
        provider_title = provider.title()

        # Attempt to get the new API key. This will prompt the user if the key is not found.
        new_api_key = get_api_key(self.log_status, self.logger, parent_window=self.root, service=provider)

        # If the user cancels the key entry dialog, abort the switch.
        if not new_api_key:
            messagebox.showwarning(
                "API Key Required",
                f"Could not set an API key for {provider_title}.\n\n"
                f"The provider has not been switched.",
                parent=self.root
            )
            # Revert the radio button to the previous setting
            self.provider_var.set(self.app_settings.get("tts_provider"))
            self.log_status(f"API key acquisition for {provider_title} failed. Provider switch cancelled.")
            return

        # If successful, update the API key in memory and in the settings.
        self.api_key = new_api_key
        self.app_settings["tts_provider"] = provider
        self.save_settings(self.app_settings)

        # Update UI to reflect the change
        self.provider_label.config(text=f"TTS Provider: {provider_title}")
        self.log_status(f"Successfully switched TTS provider to {provider_title}.")

    def update_provider_menu_state(self):
        """
        Checks for available API keys and enables/disables the provider
        menu options accordingly.
        """
        import keyring

        gemini_key_exists = bool(keyring.get_password("PodcastGenerator", "gemini_api_key"))
        elevenlabs_key_exists = bool(keyring.get_password("PodcastGenerator", "elevenlabs_api_key"))

        # Adapter à Settings menu (au lieu de self.tts_menu)
        self.settings_menu.entryconfig("Gemini", state='normal' if gemini_key_exists else 'disabled')
        self.settings_menu.entryconfig("ElevenLabs", state='normal' if elevenlabs_key_exists else 'disabled')

        # Edge case: if the current provider's key was removed, try to switch to the other one.
        current_provider = self.provider_var.get()
        if current_provider == "gemini" and not gemini_key_exists and elevenlabs_key_exists:
            self.log_status("Gemini API key not found. Switching to ElevenLabs.")
            self.provider_var.set("elevenlabs")
            self.on_provider_selected()
        elif current_provider == "elevenlabs" and not elevenlabs_key_exists and gemini_key_exists:
            self.log_status("ElevenLabs API key not found. Switching to Gemini.")
            self.provider_var.set("gemini")
            self.on_provider_selected()

    def open_api_keys_window(self):
        """Opens the API keys management window."""
        # Désactiver le menu Settings pendant l'ouverture
        self.menubar.entryconfig("Settings", state="disabled")
        APIKeysWindow(self.root, self.on_api_keys_window_close)

    def on_api_keys_window_close(self):
        """Callback to re-enable the TTS menu when API keys window is closed."""
        self.menubar.entryconfig("Settings", state="normal")
        self.update_provider_menu_state()

    def load_settings(self):
        """Loads settings from the JSON file."""
        try:
            with open(self.settings_filepath, 'r') as f:
                settings = json.load(f)
                # Load the settings as they are, preserving the rich dictionary for ElevenLabs.
                # The data will be flattened only when needed (right before generation).
                tts_provider = settings.get("tts_provider", self.DEFAULT_APP_SETTINGS["tts_provider"])
                speaker_voices = settings.get("speaker_voices", self.DEFAULT_APP_SETTINGS["speaker_voices"].copy())
                speaker_voices_elevenlabs = settings.get("speaker_voices_elevenlabs", self.DEFAULT_APP_SETTINGS["speaker_voices_elevenlabs"].copy())
                
                return {
                    "tts_provider": tts_provider,
                    "speaker_voices": speaker_voices,
                    "speaker_voices_elevenlabs": speaker_voices_elevenlabs
                }
        except (FileNotFoundError, json.JSONDecodeError):
            # Returns default app settings if the file does not exist or is corrupt
            return json.loads(json.dumps(self.DEFAULT_APP_SETTINGS))

    def save_settings(self, settings_to_save):
        """Saves the settings to the JSON file."""
        self.app_settings = settings_to_save
        try:
            os.makedirs(self.app_data_dir, exist_ok=True)  # Ensures the directory exists
            with open(self.settings_filepath, 'w') as f:
                json.dump(self.app_settings, f, indent=4)
            self.log_status("Settings saved successfully.")
        except IOError as e:
            messagebox.showerror("Saving Error", f"Cannot save settings to file:\n{e}")
            self.logger.error(f"Saving error for settings: {e}")

    def open_settings_window(self):
        """Opens the settings management window."""
        # Disable the button while the window is open to avoid duplicates
        self.menubar.entryconfig("Settings", state="disabled")
        from settings_window import SettingsWindow
        SettingsWindow(
            self.root,
            current_settings=self.app_settings,
            save_callback=self.save_settings,
            close_callback=self.on_settings_window_close,
            default_settings=self.DEFAULT_APP_SETTINGS,
            preloaded_elevenlabs_voices=self.elevenlabs_voices_cache  # <-- passe le cache
        )

    def show_about_window(self):
        """Displays the 'About' window."""
        AboutWindow(self.root)

    def open_documentation(self):
        """Opens the link to the documentation or the repository."""
        webbrowser.open_new_tab("https://github.com/laurentftech/Podcast_generator")

    def log_status(self, message: str):
        self.log_queue.put(message)

    def poll_log_queue(self):
        # We only process one message at a time to avoid blocking the event loop.
        # This ensures the interface remains responsive and can handle other tasks
        # (like on_generation_complete) between log displays.
        try:
            message = self.log_queue.get_nowait()
            if isinstance(message, tuple):
                msg_type = message[0]
                if msg_type == 'GENERATION_COMPLETE':
                    self.on_generation_complete(success=message[1])
                elif msg_type == 'UPDATE_PLAY_BUTTON':
                    self.play_button.config(text=message[1], state=message[2])
            else:
                self._update_log(message)
        except queue.Empty:
            pass  # The queue is empty, do nothing
        self.root.after(100, self.poll_log_queue)  # Check the queue every 100 ms

    def _update_log(self, message):
        self.log_text.config(state='normal')
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)
        self.log_text.config(state='disabled')

    def clear_log(self):
        """Clears the log text area."""
        self.log_text.config(state='normal')
        self.log_text.delete('1.0', tk.END)
        self.log_text.config(state='disabled')

    def load_script_from_file(self):
        """Opens a dialog to load a .txt file into the script area."""
        filepath = filedialog.askopenfilename(
            title="Open a script file",
            filetypes=(("Text files", "*.txt"), ("All files", "*.*"))
        )
        if not filepath:
            return

        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                self.script_text.delete('1.0', tk.END)
                self.script_text.insert('1.0', f.read())
            self.log_status(f"Script loaded from: {os.path.basename(filepath)}")
        except Exception as e:
            messagebox.showerror("Reading error", f"Cannot read the file:\n{e}")
            self.logger.error(f"Error reading the script: {e}")

    def start_generation_thread(self):
        """Starts the generation in a separate thread to avoid freezing the UI."""
        script_content = self.script_text.get("1.0", tk.END).strip()
        if not script_content:
            messagebox.showwarning("Empty script", "Please enter or load a script before starting generation.",
                                   parent=self.root)
            return

        # --- Validate Speaker Voices ---
        missing_speakers = validate_speakers(script_content, self.app_settings)
        if missing_speakers:
            missing_speakers_str = ", ".join(missing_speakers)
            messagebox.showerror(
                "Configuration Error",
                f"The following speakers from the script do not have an assigned voice:\n\n"
                f"{missing_speakers_str}\n\n"
                f"Please configure their voices in 'Options -> Voice Settings' before continuing.",
                parent=self.root
            )
            return

        # Ask the user where to save the output file
        output_filepath = filedialog.asksaveasfilename(
            title="Save podcast as...",
            defaultextension=".mp3",
            filetypes=(
                ("MP3", "*.mp3"),
                ("WAV", "*.wav"),
                ("All files", "*.*")
            ),
            initialdir=os.path.expanduser("~/Downloads"),
        )

        if not output_filepath:
            self.log_status("Generation cancelled by user.")
            return

        # Disable buttons during generation
        self.generate_button.config(state='disabled')
        self.load_button.config(state='disabled')
        self.play_button.config(state='disabled')
        self.show_button.config(state='disabled')
        self.menubar.entryconfig("Settings", state="disabled")

        # Show and start the progress bar
        self.clear_log()

        self.progress_bar.pack(fill=tk.X, pady=(10, 0), before=self.button_frame)
        self.progress_bar.start()

        thread = threading.Thread(
            target=self.run_generation,
            args=(script_content, output_filepath, self.app_settings, self.api_key)
        )
        thread.daemon = True
        thread.start()

    def run_generation(self, script_content, output_filepath, app_settings, api_key):
        """The function executed by the thread."""
        
        # --- Data Sanitization ---
        # Create a "clean" version of app_settings for the backend.
        # This ensures we only pass the voice ID to ElevenLabs, not the whole object.
        app_settings_clean = {
            "tts_provider": app_settings.get("tts_provider"),
            "speaker_voices": app_settings.get("speaker_voices", {})
        }
        
        elevenlabs_mapping_clean = {}
        elevenlabs_mapping_raw = app_settings.get("speaker_voices_elevenlabs", {})
        for speaker, data in elevenlabs_mapping_raw.items():
            if isinstance(data, dict):
                # New format: extract just the ID
                elevenlabs_mapping_clean[speaker] = data.get('id', '')
            else:
                # Legacy format: use the string as-is
                elevenlabs_mapping_clean[speaker] = data
        
        app_settings_clean["speaker_voices_elevenlabs"] = elevenlabs_mapping_clean
        # --- End of Data Sanitization ---

        generated_filepath = None
        try:
            self.logger.info("Starting generation thread.")
            self.log_status(f"Starting generation to '{os.path.basename(output_filepath)}'...")
            generated_filepath = self.generate_func(
                script_text=script_content,
                app_settings=app_settings_clean,  # Pass the clean version
                output_filepath=output_filepath,
                status_callback=self.log_status,
                api_key=api_key
            )
            if generated_filepath:
                self.last_generated_filepath = generated_filepath
                self.logger.info(f"Generation completed successfully. File: {generated_filepath}")
                self.log_status(
                    f"\n--- Generation completed successfully! File: {os.path.basename(generated_filepath)} ---")
            else:
                self.logger.warning("Generation function completed without returning a file path.")
                self.log_status("\n--- Generation failed. Please check the logs. ---")
        except Exception as e:
            self.logger.error(f"Unhandled error in generation thread: {e}", exc_info=True)
            self.log_status(f"A critical error occurred in the thread: {e}")
            generated_filepath = None  # Ensure the status is 'failure'
        finally:
            # We use the queue, our reliable communication channel,
            # to signal the end of the generation and its status (success/failure).
            success = bool(generated_filepath)
            self.log_queue.put(('GENERATION_COMPLETE', success))

    def on_generation_complete(self, success: bool):
        if success:
            self.root.bell()
            if self.ffplay_path:
                self.show_button.config(state='normal')
                self.play_button.config(state='normal')

        self.progress_bar.stop()
        self.generate_button.config(state='normal')
        self.load_button.config(state='normal')
        self.menubar.entryconfig("Settings", state="normal")
        if self.progress_bar.winfo_ismapped():
            self.progress_bar.pack_forget()
        self.log_text.config(state='disabled')  # Disable the log area at the very end

    def open_file_location(self):
        """Opens the folder containing the last generated file and selects it."""
        if not self.last_generated_filepath or not os.path.exists(self.last_generated_filepath):
            messagebox.showerror("File not found", "The generated audio file was not found or is no longer accessible.")
            return

        try:
            if sys.platform == "darwin":  # macOS
                # 'open -R' reveals the file in Finder
                subprocess.run(["open", "-R", self.last_generated_filepath], check=True)
            elif sys.platform == "win32":  # Windows
                # For explorer.exe, it's more reliable to use shell=True and pass
                # the command as a string, with the path properly quoted.
                filepath = os.path.normpath(self.last_generated_filepath)
                subprocess.run(f'explorer /select,"{filepath}"', shell=True)
            else:  # Linux and others (opens the containing folder)
                subprocess.run(["xdg-open", os.path.dirname(self.last_generated_filepath)], check=True)
        except (FileNotFoundError, subprocess.CalledProcessError) as e:
            messagebox.showerror("Error", f"Unable to open the file manager.\n"
                                          f"Check that system tools are accessible.\n\nError: {e}")

    def play_last_generated_file(self):
        """Plays or stops the playback of the last generated audio file."""
        if self.playback_obj and self.playback_obj.poll() is None:
            self.playback_obj.terminate()  # Stops the ffplay process if running
            return

        if not self.ffplay_path:
            messagebox.showerror(
                "Audio player not found",
                "The 'ffplay' command (part of FFmpeg) was not found.\n\n"
                "Playback is disabled. Please ensure FFmpeg is properly installed."
            )
            self.play_button.config(state='disabled')
            return

        if not self.last_generated_filepath or not os.path.exists(self.last_generated_filepath):
            messagebox.showerror("File not found", "The generated audio file was not found or is no longer accessible.")
            return

        threading.Thread(target=self._play_in_thread, daemon=True).start()

    def _play_in_thread(self):
        """The playback function executed in a separate thread."""
        try:
            creation_flags = 0
            if sys.platform == "win32":
                creation_flags = subprocess.CREATE_NO_WINDOW

            self.log_queue.put(('UPDATE_PLAY_BUTTON', '⏹️ Stop', 'normal'))
            command = [self.ffplay_path, "-nodisp", "-autoexit", "-loglevel", "quiet", self.last_generated_filepath]
            self.playback_obj = subprocess.Popen(command, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
                                                 creationflags=creation_flags)
            self.playback_obj.wait()
        except Exception as e:
            self.logger.error(f"Audio playback error with ffplay: {e}", exc_info=True)
            self.log_status(f"Audio playback error: {e}")
        finally:
            self.playback_obj = None
            if self.root.winfo_exists():
                self.log_queue.put(('UPDATE_PLAY_BUTTON', '▶️ Play', 'normal'))

    def on_settings_window_close(self):
        """Callback to re-enable the menu when the settings window is closed."""
        self.menubar.entryconfig("Settings", state="normal")
        # Update provider label in case it changed
        current_provider = self.app_settings.get("tts_provider", "gemini").title()
        self.provider_label.config(text=f"TTS Provider: {current_provider}")
        self.provider_var.set(current_provider.lower())
        self.update_provider_menu_state()


class APIKeysWindow(tk.Toplevel):
    def __init__(self, parent, close_callback):
        super().__init__(parent)
        self.title("API Keys Management")
        self.transient(parent)
        self.grab_set()
        self.resizable(False, False)
        self.close_callback = close_callback
        self.protocol("WM_DELETE_WINDOW", self.on_close)

        main_frame = tk.Frame(self, padx=20, pady=15)
        main_frame.pack(fill=tk.BOTH, expand=True)

        tk.Label(main_frame, text="Manage API Keys", font=('Helvetica', 12, 'bold')).pack(pady=(0, 15))

        # Gemini API Key section
        gemini_frame = tk.LabelFrame(main_frame, text="Google Gemini API", padx=10, pady=10)
        gemini_frame.pack(fill=tk.X, pady=(0, 10))

        self.gemini_status_label = tk.Label(gemini_frame, text="", fg="green")
        self.gemini_status_label.pack(anchor="w", pady=(0, 5))

        gemini_button_frame = tk.Frame(gemini_frame)
        gemini_button_frame.pack(fill=tk.X)

        tk.Button(gemini_button_frame, text="Set/Update Key", command=lambda: self.set_api_key("gemini")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(gemini_button_frame, text="Remove Key", command=lambda: self.remove_api_key("gemini")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(gemini_button_frame, text="Test Key", command=lambda: self.test_api_key("gemini")).pack(side=tk.LEFT)

        # ElevenLabs API Key section
        elevenlabs_frame = tk.LabelFrame(main_frame, text="ElevenLabs API", padx=10, pady=10)
        elevenlabs_frame.pack(fill=tk.X, pady=(0, 10))

        self.elevenlabs_status_label = tk.Label(elevenlabs_frame, text="", fg="green")
        self.elevenlabs_status_label.pack(anchor="w", pady=(0, 5))

        elevenlabs_button_frame = tk.Frame(elevenlabs_frame)
        elevenlabs_button_frame.pack(fill=tk.X)

        tk.Button(elevenlabs_button_frame, text="Set/Update Key", command=lambda: self.set_api_key("elevenlabs")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(elevenlabs_button_frame, text="Remove Key", command=lambda: self.remove_api_key("elevenlabs")).pack(
            side=tk.LEFT, padx=(0, 5))
        tk.Button(elevenlabs_button_frame, text="Test Key", command=lambda: self.test_api_key("elevenlabs")).pack(
            side=tk.LEFT)

        # Close button
        tk.Button(main_frame, text="Close", command=self.on_close).pack(pady=(15, 0))

        # Update status on window creation
        self.update_status()

    def update_status(self):
        """Update the status labels for both APIs."""
        import keyring

        # Check Gemini key
        gemini_key = keyring.get_password("PodcastGenerator", "gemini_api_key")
        if gemini_key:
            self.gemini_status_label.config(text="✓ API key is configured", fg="green")
        else:
            self.gemini_status_label.config(text="✗ No API key configured", fg="red")

        # Check ElevenLabs key
        elevenlabs_key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
        if elevenlabs_key:
            self.elevenlabs_status_label.config(text="✓ API key is configured", fg="green")
        else:
            self.elevenlabs_status_label.config(text="✗ No API key configured", fg="red")

    def set_api_key(self, service: str):
        """Set or update an API key for the specified service."""
        import keyring
        from tkinter import simpledialog

        if service == "elevenlabs":
            title = "ElevenLabs API Key"
            prompt = "Enter your ElevenLabs API key:"
            account = "elevenlabs_api_key"
        else:
            title = "Gemini API Key"
            prompt = "Enter your Google Gemini API key:"
            account = "gemini_api_key"

        new_key = simpledialog.askstring(title, prompt, parent=self, show="*")
        if new_key and new_key.strip():
            keyring.set_password("PodcastGenerator", account, new_key.strip())
            messagebox.showinfo("Success", f"{title} has been saved securely.", parent=self)
            self.update_status()
        elif new_key is not None:  # User clicked OK but entered empty key
            messagebox.showwarning("Invalid Key", "API key cannot be empty.", parent=self)

    def remove_api_key(self, service: str):
        """Remove an API key for the specified service."""
        import keyring

        if service == "elevenlabs":
            title = "ElevenLabs API Key"
            account = "elevenlabs_api_key"
        else:
            title = "Gemini API Key"
            account = "gemini_api_key"

        if messagebox.askyesno("Confirm Removal", f"Are you sure you want to remove the {title}?", parent=self):
            try:
                keyring.delete_password("PodcastGenerator", account)
                messagebox.showinfo("Success", f"{title} has been removed.", parent=self)
            except keyring.errors.PasswordDeleteError:
                messagebox.showinfo("Info", f"No {title} was stored.", parent=self)
            self.update_status()

    def test_api_key(self, service: str):
        """Test an API key for the specified service."""
        import keyring
        import requests
        from google import genai
        
        if service == "elevenlabs":
            key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
            if not key:
                messagebox.showwarning("No Key", "No ElevenLabs API key is configured.", parent=self)
                return
            
            # Test ElevenLabs API
            try:
                headers = {"xi-api-key": key}
                response = requests.get("https://api.elevenlabs.io/v1/user", headers=headers, timeout=10)
                if response.status_code == 200:
                    user_data = response.json()
                    subscription = user_data.get('subscription', {}).get('tier', 'Unknown')
                    messagebox.showinfo("Success", f"ElevenLabs API key is valid!\nSubscription: {subscription}", parent=self)
                elif response.status_code == 401:
                    try:
                        error_detail = response.json().get('detail', {})
                        if isinstance(error_detail, dict):
                            error_msg = error_detail.get('message', 'Invalid API key')
                        else:
                            error_msg = str(error_detail)
                    except:
                        error_msg = "Invalid or expired API key"
                    
                    messagebox.showerror("Authentication Error", 
                                       f"ElevenLabs API key test failed (401 Unauthorized):\n\n"
                                       f"{error_msg}\n\n"
                                       f"Please check:\n"
                                       f"• Key is correct and complete\n"
                                       f"• Key hasn't expired\n"
                                       f"• Account is active on elevenlabs.io", parent=self)
                else:
                    try:
                        error_detail = response.json()
                        error_msg = str(error_detail)
                    except:
                        error_msg = response.text[:200] if response.text else "Unknown error"
                    
                    messagebox.showerror("Error", 
                                       f"ElevenLabs API key test failed: {response.status_code}\n\n"
                                       f"Details: {error_msg}", parent=self)
            except requests.exceptions.RequestException as e:
                messagebox.showerror("Network Error", f"Failed to connect to ElevenLabs API:\n{str(e)}", parent=self)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to test ElevenLabs API key: {str(e)}", parent=self)
        
        else:
            key = keyring.get_password("PodcastGenerator", "gemini_api_key")
            if not key:
                messagebox.showwarning("No Key", "No Gemini API key is configured.", parent=self)
                return
            
            # Test Gemini API
            try:
                client = genai.Client(api_key=key)
                # Simple test request
                models = list(client.models.list())
                if models:
                    messagebox.showinfo("Success", f"Gemini API key is valid!\nFound {len(models)} available models.", parent=self)
                else:
                    messagebox.showwarning("Warning", "Gemini API key appears valid but no models accessible.", parent=self)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to test Gemini API key: {str(e)}", parent=self)

    def on_close(self):
        """Handle window closing."""
        self.close_callback()
        self.destroy()


# ... existing code ...

class AboutWindow(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("About Podcast Generator")
        self.transient(parent)
        self.grab_set()
        self.resizable(False, False)

        main_frame = tk.Frame(self, padx=20, pady=15)
        main_frame.pack(fill=tk.BOTH, expand=True)

        tk.Label(main_frame, text=f"Podcast Generator v{get_app_version()}", font=('Helvetica', 12, 'bold')).pack(
            pady=(0, 5))
        tk.Label(main_frame, text=f"Copyright (c) {datetime.now().year} Laurent FRANCOISE").pack()
        tk.Label(main_frame, text="Licence : MIT License").pack(pady=(0, 15))

        support_frame = tk.LabelFrame(main_frame, text="Support the projet", padx=10, pady=10)
        support_frame.pack(fill=tk.X, pady=(0, 10))

        tk.Label(support_frame, text="If this application is useful to you, you can support its development:").pack(
            pady=(0, 5))

        coffee_link = tk.Label(support_frame, text="❤️ Buy Me a Coffee", fg="blue", cursor="hand2",
                               font=('Helvetica', 10, 'bold'))
        coffee_link.pack(pady=(0, 5))
        coffee_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://buymeacoffee.com/laurentftech"))

        credits_frame = tk.LabelFrame(main_frame, text="Credits and Acknowledgements", padx=10, pady=10)
        credits_frame.pack(fill=tk.X, pady=(0, 10))

        # Gemini API link
        gemini_frame = tk.Frame(credits_frame)
        gemini_frame.pack(fill=tk.X, pady=2)
        tk.Label(gemini_frame, text="- Google Gemini API:").pack(side=tk.LEFT)
        link_label = tk.Label(gemini_frame, text="ai.google.dev/gemini-api", fg="blue", cursor="hand2")
        link_label.pack(side=tk.LEFT, padx=5)
        link_label.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://ai.google.dev/gemini-api"))

        # ElevenLabs API link
        elevenlabs_frame = tk.Frame(credits_frame)
        elevenlabs_frame.pack(fill=tk.X, pady=2)
        tk.Label(elevenlabs_frame, text="- ElevenLabs API:").pack(side=tk.LEFT)
        link_label2 = tk.Label(elevenlabs_frame, text="elevenlabs.io", fg="blue", cursor="hand2")
        link_label2.pack(side=tk.LEFT, padx=5)
        link_label2.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://elevenlabs.io"))

        tk.Label(credits_frame, text="- Tkinter for the graphical interface", anchor="w").pack(fill=tk.X, pady=2)

        # Flaticon link
        flaticon_frame = tk.Frame(credits_frame)
        flaticon_frame.pack(fill=tk.X, pady=2)
        tk.Label(flaticon_frame, text="- Icon by Smashicons from").pack(side=tk.LEFT)
        flaticon_link = tk.Label(flaticon_frame, text="flaticon.com", fg="blue", cursor="hand2")
        flaticon_link.pack(side=tk.LEFT, padx=5)
        flaticon_link.bind("<Button-1>", lambda e: webbrowser.open_new_tab("https://www.flaticon.com"))

        ok_button = tk.Button(main_frame, text="OK", command=self.destroy, width=10)
        ok_button.pack(pady=(10, 0))

        self.bind('<Return>', lambda event: ok_button.invoke())
        self.protocol("WM_DELETE_WINDOW", self.destroy)

def open_settings_window(self):
        """Opens the settings management window."""
        # Disable the button while the window is open to avoid duplicates
        self.menubar.entryconfig("Settings", state="disabled")
        from settings_window import SettingsWindow
        SettingsWindow(
            self.root,
            current_settings=self.app_settings,
            save_callback=self.save_settings,
            close_callback=self.on_settings_window_close,
            default_settings=self.DEFAULT_APP_SETTINGS,
            preloaded_elevenlabs_voices=self.elevenlabs_voices_cache  # <-- passe le cache
        )

def main():
    # Initializes the application and starts the main Tkinter loop
    # Creates the root window but hides it for now.
    # This allows for reliable display of error dialogs
    # even if the full interface initialization fails.
    root = tk.Tk()
    root.withdraw()

    # --- Import path correction ---
    # Ensures the script can find 'generate_podcast.py'
    # regardless of where it is executed from.
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        if script_dir not in sys.path:
            sys.path.insert(0, script_dir)
    except NameError:
        # __file__ is not defined in some interactive environments
        pass

    # --- Importing dependencies ---
    try:
        from generate_podcast import generate, PODCAST_SCRIPT, setup_logging, get_api_key, find_ffplay_path
    except ImportError as e:
        messagebox.showerror(
            "Import Error",
            f"The file 'generate_podcast.py' was not found.\n\n"
            f"Please ensure it is in the same folder as gui.py.\n\n"
            f"Error details: {e}"
            , parent=root)
        root.destroy()
        return

    # Initializes logging before anything else
    logger = setup_logging()

    # Create the app instance first, which populates the root window with widgets.
    # The window remains hidden for now. We pass a placeholder for the api_key.
    app = PodcastGeneratorApp(root, generate_func=generate, logger=logger, api_key="", default_script=PODCAST_SCRIPT)

    # --- API key check at startup ---
    # Fetch key for current provider (user can change provider later in settings)
    current_provider = app.app_settings.get("tts_provider", "gemini")
    api_key = get_api_key(app.log_status, logger, parent_window=root, service=current_provider)
    if not api_key:
        logger.info("Application closed because no API key was provided at startup.")
        messagebox.showwarning("API Key Required", "The application cannot start without an API key.", parent=root)
        root.destroy()
        return

    # Now that we have the key, assign it to the app and show the main window.
    app.api_key = api_key

    # Précharger les voix ElevenLabs au démarrage (si la clé est configurée)
    def _prefetch_elevenlabs():
        try:
            import keyring, requests
            key = keyring.get_password("PodcastGenerator", "elevenlabs_api_key")
            if not key:
                app.elevenlabs_voices_cache = []
                return
            headers = {"xi-api-key": key}
            resp = requests.get("https://api.elevenlabs.io/v1/voices", headers=headers, timeout=15)
            if resp.status_code != 200:
                app.elevenlabs_voices_cache = []
                return
            data = resp.json()
            voices = []
            for voice in data.get('voices', []):
                voice_id = voice.get('voice_id', '')
                name = voice.get('name', 'Unknown')
                category = voice.get('category', '')
                labels = voice.get('labels', {}) if voice.get('labels') else {}
                accent = labels.get('accent', '') if isinstance(labels, dict) else ''
                age = labels.get('age', '') if isinstance(labels, dict) else ''
                gender = labels.get('gender', '') if isinstance(labels, dict) else ''
                desc_parts = []
                if gender: desc_parts.append(str(gender).title())
                if age: desc_parts.append(str(age).title())
                if accent: desc_parts.append(str(accent))
                description = ', '.join(desc_parts) if desc_parts else str(category).title()
                display_name = f"{name} - {description}" if description else name
                voices.append({
                    'id': voice_id,
                    'name': name,
                    'display_name': display_name,
                    'category': category,
                    'labels': labels
                })
            voices.sort(key=lambda x: x.get('name', ''))
            app.elevenlabs_voices_cache = voices
        except Exception:
            app.elevenlabs_voices_cache = []

    import threading as _th
    _th.Thread(target=_prefetch_elevenlabs, daemon=True).start()

    root.deiconify()
    root.mainloop()


if __name__ == "__main__":
    main()